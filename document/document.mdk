Title         : 迪杰斯特拉派初赛文档
Author        : hy19890811
Author        : 欧阳嘉艺
Author        : HanGH
Logo          : False
Package       : [UTF8]ctex

[TITLE]

# 赛题分析 
分析赛题可知，这是一个无向图中的多约束最短路径问题，约束条件有：

1. 必经约束(必经顶点，必经边)
* 最多经过点数量约束（因为重复走过算做多次，所以可以看做是各边权值为1的最大权值约束，我们且称为步数限制）
* 禁止通过路径约束

另外，可重复走过任意节点。


# 设计思路
通过对赛题的分析，算法设计过程中主要考虑到了以下几个问题以及解决办法：

1.最短路径的子路径也是最短路径，所以求经过全部必经约束的最短路径可以分解为两两必经点的最短路径组合。但是问题是，最短路径不一定能满足最大步数约束。最小步数路径不一定是满足条件的最小距离解。


- **例1**：起点s至终点e，A走法距离10步数5，B走法距离5步数10，C走法距离8步数8，D走法距离12步数12。在限制步数为8以下时满足约束的解有最优解为C，最小步数路径和最小距离路径都不是最优路径。

- **有效路径定义：**在两点间的全部路径中，如果一条路径的距离和步数同时大于任意另外一条，那么这条路径没有价值，则它是无效的，反之则是有效的，比如**例1**中的D路径是无效的，A，B，C皆为有效路径。

- **解决思路：**与Dijkstra算法相比，floyd算法不仅能找出任意两点的最短距离路径和最少步数路径，还可以找出全部有效路径。即在每一次搜索点k使得i到j形成新的路径，如果新路径与i,j中原路径集合相比是有效路径则保存下来生成新的路径集合。



2.通过使用类floyd的算法，我们已找到任意两点间的全部有效路径集合，我们也知道需要的经过全部必经点的路径就是在在这些路径中的组合，但是在搜索算法中如何实现走过必经边约束呢？


- 解决思路：如果将一条必经边p看成两个必经点a1，a2，遍历全部必经点，再保留满足必经边约束的路径便可得到满足必经约束的路径，但是这样做显然不利于算法的灵活性和效率。所以我们把每个必经边看成两条单向路径，在搜索中如果下一个必经约束是必经边（p1,p2），就把当前路径path分为path1=path--->p1->p2和path2=path--->p2->p1(--->表示当前path到p1或p2的若干条路径，->表示p1，p2间的必经边)，这样在进行算法优化等过程中灵活性大大提高。


3.如何解决不能通过的路径？如果不能通过路径较多，如何判断是否能够到达终点或必经点是否能够到达？


- **解决思路：**在使用floyd搜索有效路径前先忽略不能通过的边， 搜索结束后如果起点与任意必经约束点或边或终点不存在任何路径，则判断该图不能经过约束条件有误。


4.已知任意两点有效路径，如何搜索出的最优路径?

- **解决思路：**这是一个时间复杂度较高的问题，在点数较少情况下任何搜索算法均能找到最优解，但要考虑到必经约束的增加问题，我们采用了dfs+剪枝的算法来解决，通过剪枝算法，可以在必经约束位置较松散的情况下有较快的搜索速度。

5.如何剪枝?

- **解决思路：**

# 代码实现
由于篇幅有限，详细代码请查看源码。以下用伪代码简要描述。

``` csharp
//Matrix[x,y].Paths表示两点x,y间的有效路径集合

从0开始对任意一个顶点k,k<n;
 对任一k取一对顶点i,j  i,j< n;
   对每对i,k,j 组合出新的路径i->k->j,
   如果新路径i->k->j是有效路径,则保存到Matrix[i,j].Paths中,并删除Matrix[i,j].Paths中的非有效路径
   
对mustPassPoints,mustPassPaths以到终点最远距离排序,使剪枝更快被发现

调用DfsPaths(s,e,mustPassPoints,mustPassPaths,null)
最后有效路径集合保留在targetPaths

DfsPaths(s,e,mustPassPoints,mustPassPaths,currentPath)
{
  如果currentPath为null,对每个必经点和边递归调用DfsPaths
  否则
  在mustPassPoints，mustPassPaths中移除当前路径已经经过的必经点和路径;
  如果已经没有剩余必经点和路径
   对当前点到终点全部路径，如果是有效路径保存到targetPaths集合中
  否则
   对每个剩余必经点
    剪枝判断，是否不再走索该必经点以后的路径，如果需要剪枝return
    否则对每个从当前点到达该必经点的路径递归调用DfsPaths
        
   对每个剩余必经路径
    剪枝判断，是否不再走索该必经路径以后的路径，如果需要剪枝return
    否则
     如果当前点在下一个必经路径的起点，递归调用DfsPaths
     否则
       对每个当前点到下一个必经路径的起点的全部路径,递归调用DfsPaths
}

```

## 算法数学模型

定义: 图_G_={_V_, _E_, _C_}。其中_V_={1, 2, ..., n}为顶点集合，_E_={_e_~1~, _e_~2~, ..., _e_~m~}为边集合，_C_={_c_~ij~ | _i_, _j_ &isin; _V_}为相应边的非负权值的集合。必经点集合为_V_~p~，必经路径集合为_E_~p~。

- 搜索图中任意两点的有效路径


1. 输入:{_V_, _E_, _C_}; 输出: 任意两点之间的路径集合_E_~q~。
2. 令{_P_~ij~ &sub; _E_~q~ | _i_, _j_ &isin; _V_}为顶点_i_到顶点_j_的所有路径集合，_P_~ij~初始值为_m_，即有_m_条路径；_E_~p~为任意两点之间的有效路径集合，{_Q_~ij~ &sub; _E_~p~| _i_, _j_ &isin; _V_}为顶点_i_到顶点_j_的有效路径集合，_Q_~ij~初始值为&empty;。假设{_p_~a~, _p_~b~ &isin; _P_~ij~ | a, b &isin;(1, m)}为集合_P_~ij~中的任意两条路径，_d_~a~为_p_~a~的花费(距离),，_d_~b~为_p_~b~的花费(距离)，_n_~a~为_p_~a~中节点数量，_n_~b~为_p_~b~中节点数量。_p_ &isin; _P_~ij~为当前路径。


a. 当_Q_~ij~ = &empty;, _p_ = (_p_~a~ or _p_~b~)时，将_p_添加到集合_Q_~ij~中，即_Q_~ij~ = {_p_}，_p_指向_P_~ij~中下一条路径，直至将_P_~ij~中的路径全部搜索。；
b. 假设_Q_~ij~ = {_p_~a~}, _p_ = _p_~b~，如果_d_~b~ &gt; _d_~a~ &amp;&amp; _n_~b~ &gt; _n_~a~，则舍弃_p_~b~，_p_指向_P_~ij~中下一条路径，_Q_~ij~仍是{_p_~a~}，即_Q_~ij~ = {_p_~a~};
c. 假设_Q_~ij~ = {_p_~a~}, _p_ = _p_~b~，如果_d_~b~ &lt; _d_~a~ &amp;&amp; _n_~b~ &lt; _n_~a~，_p_~a~则被_p_~b~替换，_p_指向_P_~ij~中下一条路径，_Q_~ij~ = {_p_~b~};
d. 假设_Q_~ij~ = {_p_~a~}, _p_ = _p_~b~，如果_d_~b~ &gt; _d_~a~ &amp;&amp; _n_~b~ &lt; _n_~a~，将_p_~b~添加到_Q_~ij~中，即_Q_~ij~ = {_p_~a~, _p_~b~}，_p_指向_P_~ij~中下一条路径;
e. 假设_Q_~ij~ = {_p_~a~}, _p_ = _p_~b~，如果_d_~b~ &lt; _d_~a~ &amp;&amp; _n_~b~ &gt; _n_~a~，将_p_~b~添加到_Q_~ij~中，即_Q_~ij~ = {_p_~a~, _p_~b~}，_p_指向_P_~ij~中下一条路径;

综上所述，这个过程的输入: {_V_, _E_, _C_}; 输出: 任意两点之间的有效路径集合_E_~p~。







## 算法优缺点分析
优点:

- 结果精确，必定能搜索出最优解（存在的话）以及所有经过必经约束的有效路径（包括等权路径）。

- 只要不改变不可通过路径约束，只使用一次类floyd算法后，任意改变其他必经约束，无需再次计算两点间有效路径。

- 通用性强，可适用于有向图，无向图，有向有回路图，多权图（稍作修改），起点终点位置无限制。

- 代码简单，灵活易改，


本算法具备很强的通用性和灵活性，具体体现在以下几个方面：

- 搜索结果方面：当满足所有约束条件的路径存在时，本算法可以求出所有满足约束条件的路径(包括等权路径)。
当不存在满足约束条件的路径时，本算法会搜索出所有有效路径(满足全部必经约束的解)，具体实例会在2.节中结合测试用例具体说明；

-  适应性方面：即使图的结构发生改变，例如改变图中的起点、终点、必经节点和必经路径，本算法仍然可以求出最优路径或者若干条有效路径。并且不仅适用于赛题给出的拓扑图，也适用于其他的拓扑图，具有很强的灵活性；

-  增减权值方面：目前，本赛题中对于路径的限制有两个权值，花费和经过节点数，如果题目中增添了权值，只需要在代码中增加相应限制权值的代码，仍然能够求出最优路径或有效路径，剪枝算法同样适应多权值，灵活性较强；

-  选取算法方面：本赛题是一个有最大通过节点数目限制的在多约束条件下求最短路径问题，其本质是一个求多源最短路径问题，
Floyd算法在求解多源最短路径具有较强的通用性，而本算法是基于Floyd算法进行修改，故也具有较强的通用性；

由于本赛题对于路径有花费和经过节点数两方面的限制，所以当最优路径不存在时，仅搜索出一条花费最少的路径和一条经过节点数最少的路径显然不满足题目要求。
本文设计的算法针对这两种限制具有很强的解决能力和通用性，能够搜索出所有有效路径作为参考。


## 算法时间复杂度分析

1. 在1.2.小节的步骤1中主要基于Floyd算法，故该算法的时间复杂为&Omicron;(an^3^)，其中n是指图中的节点总数；
a是指任意两个节点之间有效路径数量总和平均值的平方，有效路径数量总和是根据图稠密度在一个较小的常数范围内，故a始终是一个常数；

2. 在1.2.小节的步骤2中，通过剪枝优化处理将时间复杂度降低为&Omicron;(b^m^)，其中m是指题目中设定的必经节点以及必经路径的数量总和；
b代表一个较小的常数，具体是指起点到第一个必经节点(必经路径)之间的有效路径数量，或者必经节点(必经路径)到下一个必经节点(必经路径)的有效路径数量，
或者必经节点(必经路径)到终点的有效路径数量。故b的值可能会发生改变，但始终会在一个较小的常数范围内。
由于在多约束条件限制下，节点之间满足条件的路径数目较少，经过测试，本题中b的范围在3~4之间。

3.  

综上所述，本算法的时间复杂度为&Omicron;(an^3^)+&Omicron;(b^m^)，当图中节点总数与必经节点和必经路径数量总和相差较大时，
或者图中必经节点和必经路径数量较少时本算法时间复杂度可归结为&Omicron;(an^3^)，仍具有较好的性能。

## 算法实现分析

* 需要任意两点中的有效路径，使用floy算法保存任意两个节点的全部有效路径，

# 测试用例及结果分析
我们组提交的成果物中包含一个可执行文件，双击后将通过图形界面的方式进行展示。我们同样也是采用这种图形界面的方式进行测试并展示测试结果，以这种方式进行测试既直观又灵活方便，测试者可以直观的知道起点、终点、必经点、必经路径和不能走的红色路段的位置，并可随意修改这些约束调节进行测试。本文的测试用例分为两类：正常流测试和异常流测试。

- 正常流测试用例：


case1. 测试赛题给出的拓扑图及约束条件:

![case1]
[case1]: images/case1.jpg "case1" { width:auto; max-width:100% }

如上图所示，起点、终点、必经点、必经路径、不能通过的路段等约束条件均与赛题要求一致，其中节点0为起点"S"，节点17为终点"E"。在考虑路径花费和经过节点数两个权值的情况下可以搜索出两条满足所有约束条件的有效路径，通过上图右侧查看结果可知，第一条路径是距离(花费)最小且经过节点数相对较少的路径，第二条路径是经过节点数最少且距离(花费)相对较小的路径。


case2. 与某个节点相连的多条边均为必经路径，并且这个节点的多个相邻节点均为必经点:

![case2]
[case2]: images/case2.jpg "case2" { width:auto; max-width:100% }

经过修改，约束条件的设置可如上图所示，由于节点4和10的多个相邻节点和连接路径均为必经点和必经路径，存在较多的回路，故在路径花费和经过节点数相同的情况下也会存在多条有效路径。我们将所有有效路径搜索出后可通过图中右侧查看结果。"节点数:14;距离:15"的路径为满足所有约束条件下距离(花费)最小且经过节点数相对较少的路径；"节点数:12;距离:17"的路径是满足所有约束条件下经过节点数最少且距离(花费)相对较小的路径；"节点数:13;距离:16"的路径则是一条两个权值均相对较小的路径，这种路径的两个权值均在前两种路径的两个权值之间，在一个合理的范围内，本文将这种路径也当做合理的有效路径。


case3. 必经点或必经路径到终点的花费(距离)和经过节点数均大于起点(即更改起点或终点)；

![case3]
[case3]: images/case3.jpg "case3" { width:auto; max-width:100% }

将节点6设定为起点"S"，其他约束条件如上图所示，此时必经节点2、3，必经路径4->5到终点的花费(距离)和经过节点数均大于起点，此时也应该存在最优路径或有效路径。在搜索出的有效路径中"节点数:12;距离:13"的路径为满足所有约束条件下距离(花费)最小且经过节点数相对较少的路径；"节点数:10;距离:14"的路径是满足所有约束条件下经过节点数最少且距离(花费)相对较小的路径；

- 异常流测试用例


case4. 拓扑图中没有起点和终点时，会给出相应提示；

![case4]
[case4]: images/case4.jpg "case4" { width:auto; max-width:100% }
如果取消拓扑图中起点和终点的设置，运行程序后会提示"未设置起点和终点"，而并非程序崩溃。

case5. 当没有任何一条路径能够从起点到达终点时，会给出相应提示；

![case5]
[case5]: images/case5.jpg "case5" { width:auto; max-width:100% }
如上图所示，通过将连接起点的所有路径设置为不可经过的红色路段，使得没有任何一条路径能够从起点到达终点。运行程序后会给出提示，而并非程序崩溃。











[120]: images/120.png "120" { width:auto; max-width:100% }
[头像]: images/-.jpg "头像" { width:auto; max-width:100% }
Enjoy!

[reference manual]: http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html  "Madoko reference manual"
